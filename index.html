<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LDSS v6 - WebRTC Worker</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:system-ui;background:#0a0a12;color:#e0e0e0;padding:1rem;min-height:100vh}
    h1{font-size:1.3rem;background:linear-gradient(90deg,#00d4ff,#7b2cbf);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
    .header{display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;flex-wrap:wrap;gap:1rem}
    .status{display:flex;align-items:center;gap:.5rem}
    .dot{width:10px;height:10px;border-radius:50%;background:#ef4444;box-shadow:0 0 8px #ef4444}
    .dot.connected{background:#22c55e;box-shadow:0 0 8px #22c55e;animation:pulse 2s infinite}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}
    .badge{background:#7b2cbf;color:#fff;padding:.3rem .7rem;border-radius:6px;font-size:.75rem;font-weight:bold}
    .connection-box{background:rgba(34,197,94,.1);border:2px solid #22c55e;border-radius:8px;padding:1rem;margin-bottom:1rem}
    .connection-box.disconnected{background:rgba(239,68,68,.1);border-color:#ef4444}
    .connection-box h3{margin-bottom:.5rem;display:flex;align-items:center;gap:.5rem}
    .stat-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:.5rem;margin:1rem 0}
    .stat{background:rgba(0,212,255,.05);border:1px solid rgba(0,212,255,.2);border-radius:6px;padding:.5rem;text-align:center}
    .stat-val{font-size:1.5rem;font-weight:bold;color:#00d4ff}
    .stat-label{font-size:.65rem;color:#888;margin-top:.3rem}
    .log-box{background:#000;border:2px solid #7b2cbf;border-radius:8px;padding:.75rem;font-family:monospace;font-size:.75rem;max-height:300px;overflow-y:auto}
    .log-entry{padding:.3rem 0;border-bottom:1px solid #1a1a2e}
    .log-entry:last-child{border:none}
    .log-success{color:#22c55e}
    .log-error{color:#ef4444}
    .log-info{color:#00d4ff}
    .log-warning{color:#eab308}
    .log-time{color:#666;margin-right:.5rem}
    .config-box{background:rgba(234,179,8,.1);border:1px solid #eab308;border-radius:8px;padding:1rem;margin-bottom:1rem}
    .config-box input{background:#1a1a2e;border:1px solid #3a3a4e;color:#e0e0e0;padding:.5rem;border-radius:4px;width:100%;margin-top:.5rem}
    .btn{background:linear-gradient(90deg,#7b2cbf,#00d4ff);border:none;padding:.5rem 1rem;border-radius:6px;color:#fff;font-weight:600;cursor:pointer;margin-top:.5rem}
    .peer-info{background:rgba(0,0,0,.3);padding:.5rem;border-radius:4px;margin-top:.5rem;font-size:.8rem;font-family:monospace}
  </style>
</head>
<body>
  <div class="header">
    <div>
      <h1>üåê LDSS v6 - WebRTC Worker</h1>
      <span class="badge">REAL-TIME</span>
    </div>
    <div class="status">
      <div class="dot" id="dot"></div>
      <span id="status">Disconnected</span>
    </div>
  </div>

  <div class="config-box">
    <label style="color:#eab308;font-weight:600">üîß Configuration Signaling Server</label>
    <input type="text" id="signalingUrl" placeholder="https://ton-serveur.onrender.com" value="">
    <button class="btn" onclick="connectToSignaling()">üîå Connecter</button>
    <div style="font-size:.8rem;color:#888;margin-top:.5rem">
      WebRTC n√©cessite un serveur de signaling pour √©tablir la connexion P2P
    </div>
  </div>

  <div class="connection-box disconnected" id="connectionBox">
    <h3>
      <span id="connIcon">‚ö†Ô∏è</span>
      <span id="connTitle">En attente de connexion...</span>
    </h3>
    <div class="stat-grid">
      <div class="stat">
        <div class="stat-val" id="writeCount">0</div>
        <div class="stat-label">√âcritures</div>
      </div>
      <div class="stat">
        <div class="stat-val" id="readCount">0</div>
        <div class="stat-label">Lectures</div>
      </div>
      <div class="stat">
        <div class="stat-val" id="storedCount">0</div>
        <div class="stat-label">Stock√©s</div>
      </div>
      <div class="stat">
        <div class="stat-val" id="bytesTransferred">0</div>
        <div class="stat-label">KB transf√©r√©s</div>
      </div>
    </div>
    <div class="peer-info" id="peerInfo">
      Peer ID: <span id="peerId">-</span><br>
      Latence: <span id="latency">-</span>ms
    </div>
  </div>

  <div style="margin-bottom:.5rem">
    <strong style="color:#00d4ff">üìã Logs en temps r√©el</strong>
  </div>
  <div class="log-box" id="logs"></div>

  <!-- Socket.IO Client -->
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <!-- SimplePeer -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.11.1/simplepeer.min.js"></script>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LDSS v6 - WEBRTC WORKER
// Communication temps r√©el bidirectionnelle avec le serveur
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const LDSS = {
  db: null,
  socket: null,
  peer: null,
  signalingUrl: localStorage.getItem('ldss_signaling_url') || '',
  isConnected: false,
  
  stats: {
    writes: 0,
    reads: 0,
    stored: 0,
    bytesTransferred: 0
  },
  
  async init() {
    // Initialiser IndexedDB
    return new Promise((res, rej) => {
      const req = indexedDB.open('LDSS_v6', 1);
      req.onerror = () => rej(req.error);
      req.onsuccess = () => { 
        this.db = req.result; 
        res(); 
      };
      req.onupgradeneeded = e => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains('storage')) {
          const store = db.createObjectStore('storage', { keyPath: 'id' });
          store.createIndex('dataId', 'dataId', { unique: false });
          store.createIndex('timestamp', 'timestamp', { unique: false });
          store.createIndex('collection', 'collection', { unique: false });
        }
      };
    });
  },
  
  log(type, message) {
    const time = new Date().toLocaleTimeString();
    const logEl = document.getElementById('logs');
    const entry = document.createElement('div');
    entry.className = `log-entry log-${type}`;
    entry.innerHTML = `<span class="log-time">${time}</span>${message}`;
    logEl.insertBefore(entry, logEl.firstChild);
    
    while (logEl.children.length > 50) {
      logEl.removeChild(logEl.lastChild);
    }
    
    console.log(`[${type.toUpperCase()}] ${message}`);
  },
  
  updateUI() {
    document.getElementById('writeCount').textContent = this.stats.writes;
    document.getElementById('readCount').textContent = this.stats.reads;
    document.getElementById('storedCount').textContent = this.stats.stored;
    document.getElementById('bytesTransferred').textContent = Math.round(this.stats.bytesTransferred / 1024);
  },
  
  connectToSignaling(url) {
    this.signalingUrl = url;
    localStorage.setItem('ldss_signaling_url', url);
    
    this.log('info', `üîå Connexion au serveur de signaling: ${url}`);
    
    this.socket = io(url, {
      transports: ['websocket', 'polling']
    });
    
    this.socket.on('connect', () => {
      this.log('success', '‚úÖ Socket.IO connect√©');
      document.getElementById('peerId').textContent = this.socket.id;
      
      // S'annoncer comme worker
      this.socket.emit('worker-ready', { id: this.socket.id });
    });
    
    this.socket.on('disconnect', () => {
      this.log('error', '‚ùå Socket.IO d√©connect√©');
      this.isConnected = false;
      this.updateConnectionUI(false);
    });
    
    // Recevoir signal du serveur pour √©tablir WebRTC
    this.socket.on('server-signal', (signal) => {
      this.log('info', 'üì° Signal WebRTC re√ßu du serveur');
      this.initPeer(signal);
    });
    
    this.socket.on('error', (err) => {
      this.log('error', `‚ùå Erreur Socket.IO: ${err}`);
    });
  },
  
  initPeer(incomingSignal) {
    this.log('info', 'üöÄ Initialisation connexion WebRTC...');
    
    // Cr√©er peer (pas initiator car c'est le serveur qui initie)
    this.peer = new SimplePeer({
      initiator: false,
      trickle: false
    });
    
    // Quand notre signal est pr√™t, l'envoyer au serveur
    this.peer.on('signal', (signal) => {
      this.log('info', 'üì§ Envoi signal WebRTC au serveur');
      this.socket.emit('worker-signal', signal);
    });
    
    // Connexion √©tablie !
    this.peer.on('connect', () => {
      this.log('success', 'üéâ CONNEXION WEBRTC √âTABLIE !');
      this.isConnected = true;
      this.updateConnectionUI(true);
      
      // Ping pour mesurer latence
      this.startLatencyCheck();
    });
    
    // Recevoir donn√©es
    this.peer.on('data', async (data) => {
      try {
        const message = JSON.parse(data.toString());
        this.stats.bytesTransferred += data.length;
        this.updateUI();
        
        await this.handleMessage(message);
      } catch(e) {
        this.log('error', `‚ùå Erreur traitement message: ${e.message}`);
      }
    });
    
    this.peer.on('error', (err) => {
      this.log('error', `‚ùå Erreur WebRTC: ${err.message}`);
    });
    
    this.peer.on('close', () => {
      this.log('warning', '‚ö†Ô∏è Connexion WebRTC ferm√©e');
      this.isConnected = false;
      this.updateConnectionUI(false);
    });
    
    // Accepter le signal entrant
    this.peer.signal(incomingSignal);
  },
  
  async handleMessage(message) {
    const { action, requestId, collection, dataId, data } = message;
    
    this.log('info', `üì® Re√ßu: ${action} (request: ${requestId})`);
    
    try {
      let response = { requestId, success: true };
      
      switch(action) {
        case 'write':
          const writeResult = await this.write(collection, dataId, data);
          this.stats.writes++;
          response.id = writeResult.id;
          this.log('success', `‚úÖ Write: ${collection}/${dataId} (${JSON.stringify(data).length} bytes)`);
          break;
          
        case 'read':
          const readResult = await this.read(collection, dataId);
          this.stats.reads++;
          response.data = readResult;
          this.log('success', `‚úÖ Read: ${collection}/${dataId} (${readResult ? JSON.stringify(readResult).length : 0} bytes)`);
          break;
          
        case 'list':
          const listResult = await this.list(collection);
          response.items = listResult;
          this.log('success', `‚úÖ List: ${collection} (${listResult.length} items)`);
          break;
          
        case 'delete':
          await this.delete(collection, dataId);
          this.log('success', `‚úÖ Delete: ${collection}/${dataId}`);
          break;
          
        case 'ping':
          response.pong = true;
          response.timestamp = Date.now();
          break;
          
        default:
          response.success = false;
          response.error = 'Unknown action';
      }
      
      this.updateUI();
      this.send(response);
      
    } catch(e) {
      this.log('error', `‚ùå Erreur ${action}: ${e.message}`);
      this.send({ 
        requestId, 
        success: false, 
        error: e.message 
      });
    }
  },
  
  async write(collection, dataId, data) {
    return new Promise((res, rej) => {
      const tx = this.db.transaction(['storage'], 'readwrite');
      const store = tx.objectStore('storage');
      
      const record = {
        id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        collection,
        dataId,
        data,
        timestamp: Date.now(),
        size: JSON.stringify(data).length
      };
      
      const req = store.add(record);
      req.onsuccess = () => {
        this.stats.stored++;
        res({ id: record.id });
      };
      req.onerror = () => rej(req.error);
    });
  },
  
  async read(collection, dataId) {
    return new Promise((res, rej) => {
      const tx = this.db.transaction(['storage'], 'readonly');
      const store = tx.objectStore('storage');
      const idx = store.index('dataId');
      const req = idx.getAll(dataId);
      
      req.onsuccess = () => {
        const results = req.result.filter(r => r.collection === collection);
        res(results.length > 0 ? results[0].data : null);
      };
      req.onerror = () => rej(req.error);
    });
  },
  
  async list(collection) {
    return new Promise((res, rej) => {
      const tx = this.db.transaction(['storage'], 'readonly');
      const store = tx.objectStore('storage');
      const idx = store.index('collection');
      const req = idx.getAll(collection);
      
      req.onsuccess = () => {
        res(req.result.map(r => ({ dataId: r.dataId, timestamp: r.timestamp })));
      };
      req.onerror = () => rej(req.error);
    });
  },
  
  async delete(collection, dataId) {
    return new Promise((res, rej) => {
      const tx = this.db.transaction(['storage'], 'readwrite');
      const store = tx.objectStore('storage');
      const idx = store.index('dataId');
      const req = idx.getAll(dataId);
      
      req.onsuccess = () => {
        const items = req.result.filter(r => r.collection === collection);
        const deleteTx = this.db.transaction(['storage'], 'readwrite');
        const deleteStore = deleteTx.objectStore('storage');
        
        items.forEach(item => deleteStore.delete(item.id));
        
        deleteTx.oncomplete = () => res();
        deleteTx.onerror = () => rej(deleteTx.error);
      };
      req.onerror = () => rej(req.error);
    });
  },
  
  send(data) {
    if (this.peer && this.isConnected) {
      this.peer.send(JSON.stringify(data));
    }
  },
  
  startLatencyCheck() {
    setInterval(() => {
      if (this.isConnected) {
        const start = Date.now();
        this.send({ action: 'ping', timestamp: start });
        
        // On recevra le pong dans handleMessage
        const checkPong = (e) => {
          const msg = JSON.parse(e.data.toString());
          if (msg.pong) {
            const latency = Date.now() - start;
            document.getElementById('latency').textContent = latency;
            this.peer.removeListener('data', checkPong);
          }
        };
      }
    }, 5000);
  },
  
  updateConnectionUI(connected) {
    const box = document.getElementById('connectionBox');
    const icon = document.getElementById('connIcon');
    const title = document.getElementById('connTitle');
    const dot = document.getElementById('dot');
    const status = document.getElementById('status');
    
    if (connected) {
      box.classList.remove('disconnected');
      icon.textContent = 'üü¢';
      title.textContent = 'Connexion WebRTC active';
      dot.classList.add('connected');
      status.textContent = 'Connected';
    } else {
      box.classList.add('disconnected');
      icon.textContent = '‚ö†Ô∏è';
      title.textContent = 'En attente de connexion...';
      dot.classList.remove('connected');
      status.textContent = 'Disconnected';
    }
  }
};

// Exposer globalement
window.LDSS = LDSS;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UI FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function connectToSignaling() {
  const url = document.getElementById('signalingUrl').value.trim();
  if (!url) {
    alert('‚ùå URL vide');
    return;
  }
  
  LDSS.connectToSignaling(url);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INIT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

(async () => {
  try {
    await LDSS.init();
    LDSS.log('success', '‚úÖ LDSS Worker v6 initialis√© (IndexedDB)');
    
    // Charger l'URL sauvegard√©e
    if (LDSS.signalingUrl) {
      document.getElementById('signalingUrl').value = LDSS.signalingUrl;
      LDSS.log('info', '‚ÑπÔ∏è  Cliquez sur "Connecter" pour √©tablir la connexion WebRTC');
    } else {
      LDSS.log('info', '‚ÑπÔ∏è  Configurez l\'URL du serveur de signaling');
    }
    
  } catch(e) {
    LDSS.log('error', `‚ùå Erreur init: ${e.message}`);
  }
})();
</script>
</body>
</html>