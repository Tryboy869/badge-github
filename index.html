<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>LDSS Database Node</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:system-ui;background:#0a0a0f;color:#e0e0e0;padding:1.5rem;min-height:100vh}
    h1{font-size:1.5rem;color:#00d4ff;margin-bottom:.5rem}
    .status{display:flex;align-items:center;gap:.5rem;margin-bottom:1rem}
    .dot{width:10px;height:10px;border-radius:50%;background:#22c55e;box-shadow:0 0 8px #22c55e;animation:pulse 2s infinite}
    @keyframes pulse{50%{opacity:.5}}
    .card{background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.1);border-radius:8px;padding:1rem;margin-bottom:1rem}
    .endpoint{background:rgba(0,212,255,.1);border:1px solid rgba(0,212,255,.3);border-radius:6px;padding:.75rem;font-family:monospace;font-size:.85rem;margin:.5rem 0}
    #output{background:#000;border:2px solid #7b2cbf;border-radius:8px;padding:1rem;font-family:monospace;min-height:100px;white-space:pre-wrap;word-break:break-all}
    #output::before{content:"ğŸ“¤ SCRAPE THIS";display:block;color:#7b2cbf;font-size:.7rem;margin-bottom:.5rem}
    .log{font-size:.8rem;max-height:150px;overflow-y:auto;margin-top:1rem}
    .log-entry{padding:.2rem 0;border-bottom:1px solid rgba(255,255,255,.05)}
    .t{color:#666}.a{color:#00d4ff}.s{color:#22c55e}.e{color:#ef4444}
    button{background:linear-gradient(90deg,#7b2cbf,#00d4ff);border:none;padding:.5rem 1rem;border-radius:6px;color:#fff;cursor:pointer;margin:.25rem}
    input{background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.2);border-radius:4px;padding:.4rem;color:#fff;width:200px;margin:.25rem}
  </style>
</head>
<body>
  <h1>ğŸ—„ï¸ LDSS Database Node</h1>
  <div class="status"><div class="dot" id="dot"></div><span id="status">Initialisation...</span></div>
  
  <div class="card">
    <strong>Node ID:</strong> <span id="nodeId">-</span><br>
    <strong>Collections:</strong> <span id="cols">0</span> | <strong>Records:</strong> <span id="recs">0</span>
  </div>
  
  <div class="card">
    <strong>ğŸ“¡ API Endpoints (via URL):</strong>
    <div class="endpoint">?action=write&collection=users&data={"name":"John"}</div>
    <div class="endpoint">?action=read&collection=users</div>
    <div class="endpoint">?action=list</div>
    <div class="endpoint">?action=delete&collection=users&id=1</div>
    <div class="endpoint">?action=clear</div>
  </div>
  
  <div class="card">
    <strong>ğŸ”§ Test Manuel:</strong><br>
    <input id="col" placeholder="collection"><input id="data" placeholder='{"key":"value"}'>
    <button onclick="doWrite()">Write</button><button onclick="doRead()">Read</button><button onclick="doList()">List</button>
  </div>
  
  <div id="output">{"status":"loading"}</div>
  
  <!-- HIDDEN: Pour scraping facile -->
  <script type="application/json" id="ldss-result"></script>
  
  <div class="log" id="log"></div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LDSS MINI - Storage Engine
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const DB_NAME = 'LDSS_Node';
const DB_VERSION = 1;
let db = null;
const nodeId = 'node_' + Math.random().toString(36).substr(2, 8);

// Init IndexedDB
async function initDB() {
  return new Promise((res, rej) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onerror = () => rej(req.error);
    req.onsuccess = () => { db = req.result; res(); };
    req.onupgradeneeded = e => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains('store')) {
        d.createObjectStore('store', { keyPath: 'id', autoIncrement: true });
      }
    };
  });
}

// WRITE
async function write(collection, data) {
  return new Promise((res, rej) => {
    const tx = db.transaction(['store'], 'readwrite');
    const s = tx.objectStore('store');
    const record = { collection, data, ts: Date.now(), node: nodeId };
    const req = s.add(record);
    req.onsuccess = () => res({ ok: true, id: req.result, record });
    req.onerror = () => rej(req.error);
  });
}

// READ
async function read(collection) {
  return new Promise((res, rej) => {
    const tx = db.transaction(['store'], 'readonly');
    const req = tx.objectStore('store').getAll();
    req.onsuccess = () => {
      const filtered = req.result.filter(r => r.collection === collection);
      res({ ok: true, collection, count: filtered.length, data: filtered });
    };
    req.onerror = () => rej(req.error);
  });
}

// LIST ALL
async function list() {
  return new Promise((res, rej) => {
    const tx = db.transaction(['store'], 'readonly');
    const req = tx.objectStore('store').getAll();
    req.onsuccess = () => {
      const cols = {};
      req.result.forEach(r => {
        if (!cols[r.collection]) cols[r.collection] = [];
        cols[r.collection].push(r);
      });
      res({ ok: true, collections: Object.keys(cols), data: cols, total: req.result.length });
    };
    req.onerror = () => rej(req.error);
  });
}

// DELETE
async function del(collection, id) {
  return new Promise((res, rej) => {
    const tx = db.transaction(['store'], 'readwrite');
    const req = tx.objectStore('store').delete(Number(id));
    req.onsuccess = () => res({ ok: true, deleted: id });
    req.onerror = () => rej(req.error);
  });
}

// CLEAR
async function clear() {
  return new Promise((res, rej) => {
    const tx = db.transaction(['store'], 'readwrite');
    const req = tx.objectStore('store').clear();
    req.onsuccess = () => res({ ok: true, msg: 'All cleared' });
    req.onerror = () => rej(req.error);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OUTPUT & LOGGING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function output(data) {
  const json = JSON.stringify(data, null, 2);
  document.getElementById('output').textContent = json;
  document.getElementById('ldss-result').textContent = json;
  updateStats();
}

function log(action, msg, isError = false) {
  const logEl = document.getElementById('log');
  const time = new Date().toLocaleTimeString();
  logEl.innerHTML = `<div class="log-entry"><span class="t">${time}</span> <span class="a">[${action}]</span> <span class="${isError?'e':'s'}">${msg}</span></div>` + logEl.innerHTML;
}

async function updateStats() {
  try {
    const l = await list();
    document.getElementById('cols').textContent = l.collections.length;
    document.getElementById('recs').textContent = l.total;
  } catch(e) {}
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// URL PARSER - Process incoming commands
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function processURL() {
  const params = new URLSearchParams(window.location.search);
  const action = params.get('action');
  const collection = params.get('collection');
  const dataStr = params.get('data');
  const id = params.get('id');
  
  if (!action) {
    output({ status: 'ready', nodeId, msg: 'Waiting for commands...', endpoints: ['write','read','list','delete','clear'] });
    return;
  }
  
  try {
    let result;
    switch(action) {
      case 'write':
        if (!collection || !dataStr) throw new Error('Need collection & data');
        const data = JSON.parse(decodeURIComponent(dataStr));
        result = await write(collection, data);
        log('WRITE', `${collection} â†’ ID ${result.id}`);
        break;
        
      case 'read':
        if (!collection) throw new Error('Need collection');
        result = await read(collection);
        log('READ', `${collection} â†’ ${result.count} records`);
        break;
        
      case 'list':
        result = await list();
        log('LIST', `${result.collections.length} collections, ${result.total} total`);
        break;
        
      case 'delete':
        if (!collection || !id) throw new Error('Need collection & id');
        result = await del(collection, id);
        log('DELETE', `Removed ID ${id}`);
        break;
        
      case 'clear':
        result = await clear();
        log('CLEAR', 'All data wiped');
        break;
        
      default:
        throw new Error('Unknown action: ' + action);
    }
    output(result);
  } catch(e) {
    output({ ok: false, error: e.message });
    log('ERROR', e.message, true);
  }
}

// Manual test buttons
async function doWrite() {
  const col = document.getElementById('col').value || 'test';
  const dataStr = document.getElementById('data').value || '{}';
  try {
    const result = await write(col, JSON.parse(dataStr));
    output(result);
    log('WRITE', `${col} â†’ ID ${result.id}`);
  } catch(e) { output({ ok: false, error: e.message }); }
}
async function doRead() {
  const col = document.getElementById('col').value || 'test';
  const result = await read(col);
  output(result);
  log('READ', `${col} â†’ ${result.count} records`);
}
async function doList() {
  const result = await list();
  output(result);
  log('LIST', `${result.total} total records`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
(async () => {
  try {
    await initDB();
    document.getElementById('status').textContent = 'Online - Ready';
    document.getElementById('nodeId').textContent = nodeId;
    log('INIT', 'LDSS Node started');
    await processURL();
    
    // Re-process on URL change (for SPA-like behavior)
    window.addEventListener('hashchange', processURL);
    
    // Poll for URL changes (backup)
    let lastSearch = window.location.search;
    setInterval(() => {
      if (window.location.search !== lastSearch) {
        lastSearch = window.location.search;
        processURL();
      }
    }, 500);
    
  } catch(e) {
    document.getElementById('status').textContent = 'Error: ' + e.message;
    document.getElementById('dot').style.background = '#ef4444';
  }
})();
</script>
</body>
</html>