<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>LDSS Database Node v2</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:system-ui;background:#0a0a0f;color:#e0e0e0;padding:1rem;min-height:100vh}
    h1{font-size:1.3rem;color:#00d4ff;margin-bottom:.5rem}
    .status{display:flex;align-items:center;gap:.5rem;margin-bottom:1rem}
    .dot{width:10px;height:10px;border-radius:50%;background:#22c55e;box-shadow:0 0 8px #22c55e}
    .card{background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.1);border-radius:8px;padding:1rem;margin-bottom:1rem}
    #output{background:#000;border:2px solid #7b2cbf;border-radius:8px;padding:1rem;font-family:monospace;min-height:60px;white-space:pre-wrap;word-break:break-all;font-size:.85rem}
    .stats{display:grid;grid-template-columns:repeat(3,1fr);gap:.5rem;text-align:center}
    .stat{background:rgba(0,212,255,.1);padding:.5rem;border-radius:4px}
    .stat-val{font-size:1.5rem;font-weight:bold;color:#00d4ff}
    .stat-label{font-size:.7rem;color:#888}
  </style>
</head>
<body>
  <h1>üóÑÔ∏è LDSS Database Node v2</h1>
  <div class="status"><div class="dot"></div><span id="status">Ready</span></div>
  
  <div class="stats">
    <div class="stat"><div class="stat-val" id="s-cols">0</div><div class="stat-label">Collections</div></div>
    <div class="stat"><div class="stat-val" id="s-recs">0</div><div class="stat-label">Records</div></div>
    <div class="stat"><div class="stat-val" id="s-ops">0</div><div class="stat-label">Operations</div></div>
  </div>
  
  <div id="output">{"status":"ready"}</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LDSS STORAGE ENGINE v2 - Optimis√© pour le scale
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const DB = 'LDSS_v2';
let db = null;
let opCount = 0;

async function initDB() {
  return new Promise((res, rej) => {
    const req = indexedDB.open(DB, 1);
    req.onerror = () => rej(req.error);
    req.onsuccess = () => { db = req.result; res(); };
    req.onupgradeneeded = e => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains('data')) {
        const store = d.createObjectStore('data', { keyPath: 'id', autoIncrement: true });
        store.createIndex('collection', 'collection', { unique: false });
      }
    };
  });
}

// WRITE SINGLE
async function write(col, data) {
  return new Promise((res, rej) => {
    const tx = db.transaction(['data'], 'readwrite');
    const req = tx.objectStore('data').add({ collection: col, data, ts: Date.now() });
    req.onsuccess = () => { opCount++; res({ ok: true, id: req.result }); };
    req.onerror = () => rej(req.error);
  });
}

// WRITE BATCH (optimis√©)
async function writeBatch(col, items) {
  return new Promise((res, rej) => {
    const tx = db.transaction(['data'], 'readwrite');
    const store = tx.objectStore('data');
    let count = 0;
    
    for (const item of items) {
      const req = store.add({ collection: col, data: item, ts: Date.now() });
      req.onsuccess = () => count++;
    }
    
    tx.oncomplete = () => { opCount += items.length; res({ ok: true, count }); };
    tx.onerror = () => rej(tx.error);
  });
}

// READ
async function read(col) {
  return new Promise((res, rej) => {
    const tx = db.transaction(['data'], 'readonly');
    const store = tx.objectStore('data');
    const idx = store.index('collection');
    const req = idx.getAll(col);
    req.onsuccess = () => {
      opCount++;
      res({ ok: true, collection: col, count: req.result.length, data: req.result });
    };
    req.onerror = () => rej(req.error);
  });
}

// COUNT (rapide)
async function count(col) {
  return new Promise((res, rej) => {
    const tx = db.transaction(['data'], 'readonly');
    const idx = tx.objectStore('data').index('collection');
    const req = idx.count(col);
    req.onsuccess = () => { opCount++; res({ ok: true, collection: col, count: req.result }); };
    req.onerror = () => rej(req.error);
  });
}

// LIST
async function list() {
  return new Promise((res, rej) => {
    const tx = db.transaction(['data'], 'readonly');
    const req = tx.objectStore('data').getAll();
    req.onsuccess = () => {
      const cols = {};
      req.result.forEach(r => {
        if (!cols[r.collection]) cols[r.collection] = 0;
        cols[r.collection]++;
      });
      opCount++;
      res({ ok: true, collections: Object.keys(cols), counts: cols, total: req.result.length });
    };
    req.onerror = () => rej(req.error);
  });
}

// DELETE
async function del(col, id) {
  return new Promise((res, rej) => {
    const tx = db.transaction(['data'], 'readwrite');
    const req = tx.objectStore('data').delete(Number(id));
    req.onsuccess = () => { opCount++; res({ ok: true, deleted: id }); };
    req.onerror = () => rej(req.error);
  });
}

// CLEAR
async function clear() {
  return new Promise((res, rej) => {
    const tx = db.transaction(['data'], 'readwrite');
    const req = tx.objectStore('data').clear();
    req.onsuccess = () => { opCount++; res({ ok: true, msg: 'cleared' }); };
    req.onerror = () => rej(req.error);
  });
}

// OUTPUT
function out(data) {
  const json = JSON.stringify(data);
  document.getElementById('output').textContent = json;
  updateStats();
}

async function updateStats() {
  try {
    const l = await list();
    document.getElementById('s-cols').textContent = l.collections.length;
    document.getElementById('s-recs').textContent = l.total;
    document.getElementById('s-ops').textContent = opCount;
  } catch(e) {}
}

// URL ROUTER
async function route() {
  const p = new URLSearchParams(location.search);
  const action = p.get('action');
  const col = p.get('collection');
  const dataStr = p.get('data');
  const id = p.get('id');
  
  if (!action) { out({ status: 'ready', actions: ['write','write_batch','read','count','list','delete','clear'] }); return; }
  
  try {
    let r;
    switch(action) {
      case 'write':
        r = await write(col, JSON.parse(decodeURIComponent(dataStr)));
        break;
      case 'write_batch':
        const batch = JSON.parse(decodeURIComponent(dataStr));
        r = await writeBatch(col, batch.batch || batch);
        break;
      case 'read':
        r = await read(col);
        break;
      case 'count':
        r = await count(col);
        break;
      case 'list':
        r = await list();
        break;
      case 'delete':
        r = await del(col, id);
        break;
      case 'clear':
        r = await clear();
        break;
      default:
        r = { ok: false, error: 'unknown action' };
    }
    out(r);
  } catch(e) {
    out({ ok: false, error: e.message });
  }
}

// INIT
(async () => {
  await initDB();
  document.getElementById('status').textContent = 'Online';
  await route();
})();
</script>
</body>
</html>